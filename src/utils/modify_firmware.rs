use std::collections::HashMap;

pub fn patch_firmware(
    original_binary: &[u8],
    id_layout_layer0: &HashMap<u32, u8>,
    id_layout_layer1: &HashMap<u32, u8>,
    tp_sensitivity: u32, 
) -> Result<Vec<u8>, String> {
    let mut data = original_binary.to_vec();

    // 1. Patch layer constants
    patch_layer_constants(&mut data)?;

    // 2. Layer 0 Key Remap
    for (&offset, &new_id) in id_layout_layer0 {
        let offset: usize = offset.try_into().unwrap();
        let new_xored_id = new_id ^ 0x5A;
        if offset >= data.len() {
            return Err(format!("Offset out of range in layer 0: {}", offset));
        }
        data[offset] = new_xored_id;
    }

    // 3. Layer 1 Key Remap
    for (&offset, &new_id) in id_layout_layer1 {
        let offset: usize = offset.try_into().unwrap();
        let new_xored_id = new_id ^ 0x5A;
        if offset >= data.len() - 1 {
            return Err(format!("Offset out of range in layer 1: {}", offset));
        }
        if data[offset] == 0xBD && new_xored_id != 0xBD {
            return Err(format!(
                "MO(1) key must be mapped at the same position in layer 0 and 1 (offset {}).",
                offset
            ));
        }
        data[offset + 1] = new_xored_id;
    }

    // 4. TrackPoint Sensitivity
    patch_tp_settings(&mut data, tp_sensitivity)?;

    Ok(data)
}

fn patch_layer_constants(data: &mut Vec<u8>) -> Result<(), String> {
    let address_start = 0x73A49;
    let address_end = 0x73A9A;
    let address_3rd = 0x73D10;
    let address_4th = 0x73D14;

    const EXPECTED_VALUES: [u8; 82] = [
        0x01, 0xB8, 0xD8, 0x15, 0x9F, 0xDC, 0x28, 0x13, 0xDE, 0xBF, 0xD8, 0xA7, 0x9E, 0xDC, 0x28,
        0x13, 0xDE, 0x55, 0x44, 0xF5, 0x5C, 0xAE, 0xD8, 0x2E, 0x74, 0xDC, 0x2A, 0x5A, 0x54, 0x5A,
        0x1A, 0x5A, 0x01, 0x5A, 0x12, 0x49, 0x13, 0x49, 0x12, 0x49, 0x16, 0x49, 0x14, 0x49, 0x15,
        0x13, 0xDE, 0x5A, 0x02, 0x44, 0xD9, 0x54, 0x5C, 0xA1, 0xD8, 0x1D, 0x77, 0x55, 0x45, 0x1E,
        0xDE, 0x49, 0x5C, 0x5A, 0xD9, 0x12, 0x77, 0x55, 0x45, 0x1E, 0xDE, 0x5F, 0x5C, 0x5C, 0xD9,
        0x48, 0x17, 0x49, 0x12, 0x65, 0x71, 0x13,
    ];

    const NEW_VALUES: [u8; 82] = [
        0x0D, 0xBE, 0xD8, 0x5A, 0x01, 0xB2, 0xD8, 0x15, 0x9F, 0xDC, 0x28, 0x13, 0xDE, 0xB1, 0xD8,
        0xD8, 0x44, 0x55, 0x45, 0x84, 0xD8, 0x5A, 0x5A, 0xA7, 0x9E, 0xDC, 0x28, 0x13, 0xDE, 0x55,
        0x44, 0xF5, 0x5C, 0xA0, 0xD8, 0x2E, 0x74, 0xDC, 0x2A, 0x5A, 0x54, 0x5A, 0x1A, 0x5A, 0x01,
        0x5A, 0x12, 0x49, 0x13, 0x49, 0x12, 0x49, 0x16, 0x49, 0x14, 0x49, 0x15, 0x13, 0xDE, 0x5A,
        0x02, 0x44, 0xD9, 0x0A, 0x5C, 0x5B, 0xD9, 0x10, 0x77, 0x55, 0x45, 0x1E, 0xDE, 0x15, 0x5C,
        0x5C, 0xD9, 0x17, 0x77, 0x55, 0x45, 0x1E,
    ];

    if data.len() <= address_end {
        return Err("Firmware data too small".to_string());
    }

    if &data[address_start..=address_end] != EXPECTED_VALUES {
        return Err(format!(
            "Invalid bytes between {:#X} and {:#X}",
            address_start, address_end
        ));
    }

    data[address_start..=address_end].copy_from_slice(&NEW_VALUES);

    if data.get(address_3rd) != Some(&0x4F) {
        return Err(format!("Unexpected value at address {:#X}", address_3rd));
    }
    if data.get(address_4th) != Some(&0x4F) {
        return Err(format!("Unexpected value at address {:#X}", address_4th));
    }

    data[address_3rd] = 0x5A;
    data[address_4th] = 0x5A;

    Ok(())
}


fn patch_tp_settings(data: &mut Vec<u8>, tp_sensitivity: u32) -> Result<(), String> {
    let address_start = 0x74210;
    let address_end = 0x7444F;
    let address_tp_accelerate_start = 0x74244;
    let address_tp_accelerate_end = 0x7424D;

    const EXPECTED_VALUES: [u8; 576] = [
        0xD3, 0x9C, 0xDA, 0x5C, 0x88, 0xDC, 0xFE, 0x9C, 0xD3, 0x9C, 0x1F, 0x45, 0xFE, 0x9C, 0xDD, 0x9D, 
        0xD3, 0x9C, 0x68, 0x45, 0xFE, 0x9C, 0xD3, 0x9C, 0xA5, 0x47, 0x5B, 0x4E, 0x69, 0x45, 0xFE, 0x9C, 
        0xD3, 0x9C, 0xFD, 0x9C, 0x17, 0x19, 0x8F, 0xDC, 0x17, 0x11, 0x74, 0x9C, 0x48, 0x0C, 0x81, 0xDC, 
        0x54, 0x92, 0x6B, 0x92, 0xED, 0x9D, 0x48, 0x04, 0x5A, 0x54, 0x68, 0x44, 0x6E, 0x45, 0x69, 0x44, 
        0x6F, 0x45, 0x6E, 0x05, 0xBD, 0xDC, 0x6E, 0x44, 0xA5, 0x47, 0x5B, 0x4E, 0x6E, 0x45, 0xDC, 0x38, 
        0x6E, 0x53, 0x6F, 0x05, 0xB5, 0xDC, 0x6F, 0x44, 0xA5, 0x47, 0x5B, 0x4E, 0x6F, 0x45, 0x6E, 0x44, 
        0x6F, 0x78, 0xDC, 0x28, 0x4B, 0xDD, 0x68, 0x44, 0x6E, 0x45, 0x69, 0x44, 0x6F, 0x45, 0x6E, 0x05, 
        0xA7, 0xDC, 0x6E, 0x44, 0xA5, 0x47, 0x5B, 0x4E, 0x6E, 0x45, 0x6F, 0x05, 0x59, 0xDD, 0x6F, 0x44, 
        0xA5, 0x47, 0x5B, 0x4E, 0x6F, 0x45, 0xDC, 0x38, 0x6F, 0x53, 0x6F, 0x44, 0x6E, 0x78, 0xDC, 0x28, 
        0x17, 0xDD, 0x74, 0x71, 0x75, 0x71, 0x6A, 0x71, 0x6B, 0x71, 0x6C, 0x71, 0x6D, 0x71, 0x49, 0x18, 
        0x5A, 0x54, 0x6C, 0x71, 0x6A, 0x71, 0x4E, 0x0F, 0x41, 0xDD, 0x4E, 0x1C, 0x68, 0x44, 0xDC, 0x22, 
        0x41, 0xDD, 0x4E, 0x14, 0x5A, 0x54, 0x68, 0x05, 0x6E, 0xDD, 0x68, 0x44, 0x6D, 0x25, 0x78, 0xDD, 
        0x6D, 0x49, 0x79, 0xDD, 0x6D, 0x45, 0x6D, 0x44, 0x57, 0x4E, 0xDC, 0x20, 0x74, 0xDD, 0x49, 0x01, 
        0x77, 0xDD, 0xA5, 0x77, 0x6B, 0x41, 0x5B, 0x4E, 0x6B, 0x45, 0x5A, 0x54, 0x6D, 0x45, 0x5B, 0x77, 
        0x6B, 0x49, 0x49, 0x11, 0x79, 0xDD, 0x5A, 0x54, 0x68, 0x44, 0x6D, 0x2D, 0x63, 0xDD, 0x6D, 0x49, 
        0x60, 0xDD, 0x6D, 0x45, 0x68, 0x44, 0x6D, 0x49, 0x6D, 0x44, 0x57, 0x7E, 0xDC, 0x28, 0x1D, 0xDD, 
        0x49, 0x01, 0x1C, 0xDD, 0xA5, 0x77, 0x6B, 0x41, 0x5B, 0x4E, 0x6B, 0x45, 0x5A, 0x54, 0x6D, 0x45, 
        0xA5, 0x77, 0x6B, 0x49, 0x49, 0x11, 0x66, 0xDD, 0x5A, 0x54, 0x6B, 0x71, 0x6D, 0x71, 0x4E, 0x0F, 
        0x0D, 0xDD, 0x4E, 0x1C, 0x69, 0x44, 0xDC, 0x22, 0x0D, 0xDD, 0x4E, 0x14, 0x5A, 0x54, 0x69, 0x05, 
        0x35, 0xDD, 0x69, 0x44, 0x6C, 0x05, 0x04, 0xDD, 0x6C, 0x49, 0x05, 0xDD, 0x6C, 0x45, 0x6C, 0x44, 
        0x48, 0x4E, 0xDC, 0x28, 0x5A, 0x54, 0x6C, 0x45, 0x5B, 0x77, 0x6A, 0x49, 0x4E, 0x0F, 0x31, 0xDD, 
        0x49, 0x10, 0x49, 0x19, 0x37, 0xDD, 0x49, 0x18, 0x49, 0x11, 0x05, 0xDD, 0x5A, 0x54, 0x69, 0x44, 
        0x6C, 0x2D, 0x2E, 0xDD, 0x6C, 0x49, 0x2F, 0xDD, 0x6C, 0x45, 0x69, 0x44, 0x6C, 0x49, 0x6C, 0x44, 
        0x48, 0x7E, 0xDC, 0x20, 0x5A, 0x54, 0x6C, 0x45, 0xA5, 0x77, 0x6A, 0x49, 0x4E, 0x0F, 0xD9, 0xDD, 
        0x49, 0x10, 0x49, 0x19, 0xDF, 0xDD, 0x49, 0x18, 0x49, 0x11, 0x2D, 0xDD, 0x5A, 0x54, 0x76, 0x1A, 
        0x1F, 0x0A, 0x76, 0x12, 0x76, 0x1B, 0x1F, 0x0B, 0x76, 0x13, 0x4E, 0x0F, 0xC8, 0xDD, 0x76, 0x18, 
        0x1F, 0x08, 0x76, 0x10, 0x76, 0x44, 0x77, 0x5D, 0xCD, 0xDD, 0x49, 0x18, 0xC0, 0xDD, 0x76, 0x44, 
        0x77, 0x45, 0x49, 0x10, 0x4E, 0x0F, 0xFA, 0xDD, 0x48, 0x1C, 0x76, 0x08, 0x48, 0x14, 0xEC, 0xDD, 
        0x76, 0x18, 0x1F, 0x44, 0x5E, 0x70, 0x22, 0x5D, 0xFD, 0xDD, 0x49, 0x1C, 0xEC, 0xDD, 0x1F, 0x44, 
        0x5E, 0x70, 0x22, 0x45, 0x49, 0x14, 0x22, 0x00, 0xE9, 0xDD, 0x5A, 0x77, 0x72, 0x45, 0x5E, 0x77, 
        0x73, 0x45, 0x48, 0x14, 0xEC, 0xDD, 0x72, 0x71, 0x73, 0x71, 0x48, 0x1C, 0x5A, 0x54, 0x68, 0x44, 
        0xDC, 0x2A, 0x94, 0xDD, 0x49, 0x10, 0x74, 0x0D, 0x9C, 0xDD, 0x68, 0x44, 0x74, 0x49, 0x68, 0x0D, 
        0x94, 0xDD, 0x74, 0x05, 0x94, 0xDD, 0x25, 0x77, 0x74, 0x45, 0x94, 0xDD, 0x68, 0x74, 0x74, 0x49, 
        0x68, 0x05, 0x94, 0xDD, 0x74, 0x0D, 0x94, 0xDD, 0xDB, 0x77, 0x74, 0x45, 0x69, 0x44, 0xDC, 0x2A, 
        0xBF, 0xDD, 0x49, 0x10, 0x75, 0x0D, 0x87, 0xDD, 0x69, 0x44, 0x75, 0x49, 0x69, 0x0D, 0xBF, 0xDD, 
        0x75, 0x05, 0xBF, 0xDD, 0x25, 0x77, 0x75, 0x45, 0xBF, 0xDD, 0x69, 0x44, 0x75, 0x49, 0x69, 0x05
    ];

    const NEW_VALUES: [u8; 576] = [
        0xD3, 0x9C, 0xDA, 0x5C, 0x88, 0xDC, 0xFE, 0x9C, 0xD3, 0x9C, 0x1F, 0x45, 0xFE, 0x9C, 0xD1, 0x9D, 
        0xD3, 0x9C, 0x68, 0x45, 0xFE, 0x9C, 0xD3, 0x9C, 0xA5, 0x47, 0x5B, 0x4E, 0x69, 0x45, 0xFE, 0x9C, 
        0xD3, 0x9C, 0xFD, 0x9C, 0x17, 0x19, 0x8F, 0xDC, 0x17, 0x11, 0x74, 0x9C, 0x48, 0x0C, 0x85, 0xDC, 
        0x54, 0x92, 0x6B, 0x92, 0xE1, 0x9D, 0xE1, 0x9D, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x48, 0x04, 
        0x5A, 0x54, 0x68, 0x44, 0x6E, 0x45, 0x69, 0x44, 0x6F, 0x45, 0x6E, 0x05, 0xB1, 0xDC, 0x6E, 0x44, 
        0xA5, 0x47, 0x5B, 0x4E, 0x6E, 0x45, 0xDC, 0x38, 0x6E, 0x53, 0x6F, 0x05, 0xA9, 0xDC, 0x6F, 0x44, 
        0xA5, 0x47, 0x5B, 0x4E, 0x6F, 0x45, 0x6E, 0x44, 0x6F, 0x78, 0xDC, 0x28, 0x4F, 0xDD, 0x68, 0x44, 
        0x6E, 0x45, 0x69, 0x44, 0x6F, 0x45, 0x6E, 0x05, 0x5B, 0xDD, 0x6E, 0x44, 0xA5, 0x47, 0x5B, 0x4E, 
        0x6E, 0x45, 0x6F, 0x05, 0x5D, 0xDD, 0x6F, 0x44, 0xA5, 0x47, 0x5B, 0x4E, 0x6F, 0x45, 0xDC, 0x38, 
        0x6F, 0x53, 0x6F, 0x44, 0x6E, 0x78, 0xDC, 0x28, 0x0B, 0xDD, 0x74, 0x71, 0x75, 0x71, 0x6A, 0x71, 
        0x6B, 0x71, 0x6C, 0x71, 0x6D, 0x71, 0x49, 0x18, 0x5A, 0x54, 0x6C, 0x71, 0x6A, 0x71, 0x4E, 0x0F, 
        0x45, 0xDD, 0x4E, 0x1C, 0x68, 0x44, 0xDC, 0x22, 0x45, 0xDD, 0x4E, 0x14, 0x5A, 0x54, 0x68, 0x05, 
        0x62, 0xDD, 0x68, 0x44, 0x6D, 0x25, 0x7C, 0xDD, 0x6D, 0x49, 0x7D, 0xDD, 0x6D, 0x45, 0x6D, 0x44, 
        0x57, 0x4E, 0xDC, 0x20, 0x68, 0xDD, 0x49, 0x01, 0x6B, 0xDD, 0xA5, 0x77, 0x6B, 0x41, 0x5B, 0x4E, 
        0x6B, 0x45, 0x5A, 0x54, 0x6D, 0x45, 0x5B, 0x77, 0x6B, 0x49, 0x49, 0x11, 0x7D, 0xDD, 0x5A, 0x54, 
        0x68, 0x44, 0x6D, 0x2D, 0x67, 0xDD, 0x6D, 0x49, 0x64, 0xDD, 0x6D, 0x45, 0x68, 0x44, 0x6D, 0x49, 
        0x6D, 0x44, 0x57, 0x7E, 0xDC, 0x28, 0x11, 0xDD, 0x49, 0x01, 0x10, 0xDD, 0xA5, 0x77, 0x6B, 0x41, 
        0x5B, 0x4E, 0x6B, 0x45, 0x5A, 0x54, 0x6D, 0x45, 0xA5, 0x77, 0x6B, 0x49, 0x49, 0x11, 0x1A, 0xDD, 
        0x5A, 0x54, 0x6B, 0x71, 0x6D, 0x71, 0x4E, 0x0F, 0x01, 0xDD, 0x4E, 0x1C, 0x69, 0x44, 0xDC, 0x22, 
        0x01, 0xDD, 0x4E, 0x14, 0x5A, 0x54, 0x69, 0x05, 0x29, 0xDD, 0x69, 0x44, 0x6C, 0x05, 0x38, 0xDD, 
        0x6C, 0x49, 0x39, 0xDD, 0x6C, 0x45, 0x6C, 0x44, 0x48, 0x4E, 0xDC, 0x28, 0x5A, 0x54, 0x6C, 0x45, 
        0x5B, 0x77, 0x6A, 0x49, 0x4E, 0x0F, 0x35, 0xDD, 0x49, 0x10, 0x49, 0x19, 0x2B, 0xDD, 0x49, 0x18, 
        0x49, 0x11, 0x39, 0xDD, 0x5A, 0x54, 0x69, 0x44, 0x6C, 0x2D, 0x22, 0xDD, 0x6C, 0x49, 0x23, 0xDD, 
        0x6C, 0x45, 0x69, 0x44, 0x6C, 0x49, 0x6C, 0x44, 0x48, 0x7E, 0xDC, 0x20, 0x5A, 0x54, 0x6C, 0x45, 
        0xA5, 0x77, 0x6A, 0x49, 0x4E, 0x0F, 0xDD, 0xDD, 0x49, 0x10, 0x49, 0x19, 0xD3, 0xDD, 0x49, 0x18, 
        0x49, 0x11, 0x21, 0xDD, 0x5A, 0x54, 0x76, 0x1A, 0x1F, 0x0A, 0x76, 0x12, 0x76, 0x1B, 0x1F, 0x0B, 
        0x76, 0x13, 0x4E, 0x0F, 0xCC, 0xDD, 0x76, 0x18, 0x1F, 0x08, 0x76, 0x10, 0x76, 0x44, 0x77, 0x5D, 
        0xC1, 0xDD, 0x49, 0x18, 0xC4, 0xDD, 0x76, 0x44, 0x77, 0x45, 0x49, 0x10, 0x4E, 0x0F, 0xFE, 0xDD, 
        0x48, 0x1C, 0x76, 0x08, 0x48, 0x14, 0xE0, 0xDD, 0x76, 0x18, 0x1F, 0x44, 0x5E, 0x70, 0x22, 0x5D, 
        0xF1, 0xDD, 0x49, 0x1C, 0xE0, 0xDD, 0x1F, 0x44, 0x5E, 0x70, 0x22, 0x45, 0x49, 0x14, 0x22, 0x00, 
        0xED, 0xDD, 0x5A, 0x77, 0x72, 0x45, 0x5E, 0x77, 0x73, 0x45, 0x48, 0x14, 0xE0, 0xDD, 0x72, 0x71, 
        0x73, 0x71, 0x48, 0x1C, 0x5A, 0x54, 0x68, 0x44, 0xDC, 0x2A, 0x8A, 0xDD, 0x49, 0x10, 0x74, 0x0D, 
        0x93, 0xDD, 0x74, 0x49, 0x68, 0x0D, 0x8A, 0xDD, 0x74, 0x05, 0x8A, 0xDD, 0x25, 0x77, 0x74, 0x45, 
        0x8A, 0xDD, 0x74, 0x49, 0x68, 0x05, 0x8A, 0xDD, 0x74, 0x0D, 0x8A, 0xDD, 0xDB, 0x77, 0x74, 0x45, 
        0x69, 0x44, 0xDC, 0x2A, 0xBF, 0xDD, 0x49, 0x10, 0x75, 0x0D, 0x84, 0xDD, 0x75, 0x49, 0x69, 0x0D, 
        0xBF, 0xDD, 0x75, 0x05, 0xBF, 0xDD, 0x25, 0x77, 0x75, 0x45, 0xBF, 0xDD, 0x75, 0x49, 0x69, 0x05
    ];

    const X2_VALUES: [u8; 10] = [0xE1, 0x9D, 0xE1, 0x9D, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A];
    const X3_VALUES: [u8; 10] = [0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D, 0x5A, 0x5A, 0x5A, 0x5A];
    const X4_VALUES: [u8; 10] = [0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D, 0x5A, 0x5A];
    const X5_VALUES: [u8; 10] = [0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D, 0xE1, 0x9D];

    if data.len() <= address_end {
        return Err("Firmware data too small".to_string());
    }

    let tp_value = match tp_sensitivity {
        2 => Some(&X2_VALUES),
        3 => Some(&X3_VALUES),
        4 => Some(&X4_VALUES),
        5 => Some(&X5_VALUES),
        _ => None,
    };
    
    if let Some(tp_values) = tp_value {
        if &data[address_start..=address_end] != EXPECTED_VALUES {
            return Err(format!(
                "Invalid bytes between {:#X} and {:#X}",
                address_start, address_end
            ));
        }
        data[address_start..=address_end].copy_from_slice(&NEW_VALUES);
        data[address_tp_accelerate_start..=address_tp_accelerate_end].copy_from_slice(tp_values);
    }
    
    Ok(())

}


pub fn extract_fw_bin(input_data: &[u8]) -> Vec<u8> {
    const SN8_OFFSET: usize = 472208;
    const SN8_LENGTH: usize = 24576;
    const XOR_KEY: u8 = 0x5A;

    input_data
        .get(SN8_OFFSET..SN8_OFFSET + SN8_LENGTH)
        .unwrap_or(&[])
        .iter()
        .map(|&b| b ^ XOR_KEY)
        .collect()
}
