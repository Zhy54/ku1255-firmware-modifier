use std::collections::HashMap;

pub fn patch_firmware(
    original_binary: &[u8],
    id_layout_layer0: &HashMap<u32, u8>,
    id_layout_layer1: &HashMap<u32, u8>,
) -> Result<Vec<u8>, String> {
    let mut data = original_binary.to_vec();

    // 1. Patch layer constants
    patch_layer_constants(&mut data)?;

    // 2. Layer 0 Key Remap
    for (&offset, &new_id) in id_layout_layer0 {
        let offset: usize = offset.try_into().unwrap();
        let new_xored_id = new_id ^ 0x5A;
        if offset >= data.len() {
            return Err(format!("Offset out of range in layer 0: {}", offset));
        }
        data[offset] = new_xored_id;
    }

    // 3. Layer 1 Key Remap
    for (&offset, &new_id) in id_layout_layer1 {
        let offset: usize = offset.try_into().unwrap();
        let new_xored_id = new_id ^ 0x5A;
        if offset >= data.len() - 1 {
            return Err(format!("Offset out of range in layer 1: {}", offset));
        }
        if data[offset] == 0xBD && new_xored_id != 0xBD {
            return Err(format!(
                "MO(1) key must be mapped at the same position in layer 0 and 1 (offset {}).",
                offset
            ));
        }
        data[offset + 1] = new_xored_id;
    }

    Ok(data)
}

fn patch_layer_constants(data: &mut Vec<u8>) -> Result<(), String> {
    let address_start = 0x73A49;
    let address_end = 0x73A9A;
    let address_3rd = 0x73D10;
    let address_4th = 0x73D14;

    const EXPECTED_VALUES: [u8; 82] = [
        0x01, 0xB8, 0xD8, 0x15, 0x9F, 0xDC, 0x28, 0x13, 0xDE, 0xBF, 0xD8, 0xA7, 0x9E, 0xDC, 0x28,
        0x13, 0xDE, 0x55, 0x44, 0xF5, 0x5C, 0xAE, 0xD8, 0x2E, 0x74, 0xDC, 0x2A, 0x5A, 0x54, 0x5A,
        0x1A, 0x5A, 0x01, 0x5A, 0x12, 0x49, 0x13, 0x49, 0x12, 0x49, 0x16, 0x49, 0x14, 0x49, 0x15,
        0x13, 0xDE, 0x5A, 0x02, 0x44, 0xD9, 0x54, 0x5C, 0xA1, 0xD8, 0x1D, 0x77, 0x55, 0x45, 0x1E,
        0xDE, 0x49, 0x5C, 0x5A, 0xD9, 0x12, 0x77, 0x55, 0x45, 0x1E, 0xDE, 0x5F, 0x5C, 0x5C, 0xD9,
        0x48, 0x17, 0x49, 0x12, 0x65, 0x71, 0x13,
    ];

    const NEW_VALUES: [u8; 82] = [
        0x0D, 0xBE, 0xD8, 0x5A, 0x01, 0xB2, 0xD8, 0x15, 0x9F, 0xDC, 0x28, 0x13, 0xDE, 0xB1, 0xD8,
        0xD8, 0x44, 0x55, 0x45, 0x84, 0xD8, 0x5A, 0x5A, 0xA7, 0x9E, 0xDC, 0x28, 0x13, 0xDE, 0x55,
        0x44, 0xF5, 0x5C, 0xA0, 0xD8, 0x2E, 0x74, 0xDC, 0x2A, 0x5A, 0x54, 0x5A, 0x1A, 0x5A, 0x01,
        0x5A, 0x12, 0x49, 0x13, 0x49, 0x12, 0x49, 0x16, 0x49, 0x14, 0x49, 0x15, 0x13, 0xDE, 0x5A,
        0x02, 0x44, 0xD9, 0x0A, 0x5C, 0x5B, 0xD9, 0x10, 0x77, 0x55, 0x45, 0x1E, 0xDE, 0x15, 0x5C,
        0x5C, 0xD9, 0x17, 0x77, 0x55, 0x45, 0x1E,
    ];

    if data.len() <= address_end {
        return Err("Firmware data too small".to_string());
    }

    if &data[address_start..=address_end] != EXPECTED_VALUES {
        return Err(format!(
            "Invalid bytes between {:#X} and {:#X}",
            address_start, address_end
        ));
    }

    data[address_start..=address_end].copy_from_slice(&NEW_VALUES);

    if data.get(address_3rd) != Some(&0x4F) {
        return Err(format!("Unexpected value at address {:#X}", address_3rd));
    }
    if data.get(address_4th) != Some(&0x4F) {
        return Err(format!("Unexpected value at address {:#X}", address_4th));
    }

    data[address_3rd] = 0x5A;
    data[address_4th] = 0x5A;

    Ok(())
}
